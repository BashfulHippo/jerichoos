; __________Minimal Bootloader__________
; File: boot/boot.asm
;
; Description: Minimal x86 bootloader that prints a message to screen.
;
; Memory Layout:
;   - BIOS loads this code to 0x7C00
;   - Stack grows downward from 0x7C00
;   - Code executes in 16-bit real mode.
;
; Boot Signature: Bytes 510-511 must be 0xAA55 for BIOS to recognize boot sector
;==============================================================================

[BITS 16]           ; We start in 16-bit real mode
[ORG 0x7C00]        ; BIOS loads boot sector to this address

; ___________________________________
; execution here
; ___________________________________
start:
    ; Clear interrupts while we set up
    cli

    ; Set up segments (in real mode, segments are 16-bit)
    ; DS = Data Segment, ES = Extra Segment, SS = Stack Segment
    xor ax, ax      ; AX = 0
    mov ds, ax      ; DS = 0
    mov es, ax      ; ES = 0
    mov ss, ax      ; SS = 0
    mov sp, 0x7C00  ; Stack pointer at 0x7C00 (grows downward)

    ; Re-enable interrupts
    sti

    ; Print our boot message
    mov si, msg_boot    ; SI = pointer to message string
    call print_string   ; Call our print function

    ; Infinite loop - hang here after booting
hang:
    hlt                 ; Halt CPU until next interrupt
    jmp hang            ; Jump back (in case of spurious interrupt)

;------------------------------------------------------------------------------
; Function: print_string
; Description: Print a null-terminated string to screen using BIOS interrupts
;
; Input: SI = pointer to null-terminated string
; Output: String printed to screen at current cursor position
; Modifies: AX, BX, SI
;------------------------------------------------------------------------------
print_string:
    pusha               ; Save all general-purpose registers
    mov ah, 0x0E        ; BIOS teletype function (INT 0x10, AH=0x0E)
    mov bh, 0x00        ; Page number = 0
    mov bl, 0x07        ; Text attribute = light gray on black

.loop:
    lodsb               ; Load byte from [SI] into AL, increment SI
    test al, al         ; Check if AL == 0 (null terminator)
    jz .done            ; If zero, string is done
    int 0x10            ; Call BIOS interrupt to print character
    jmp .loop           ; Continue to next character

.done:
    popa                ; Restore all registers
    ret                 ; Return to caller

;------------------------------------------------------------------------------
; Data Section
;------------------------------------------------------------------------------
msg_boot: db 'JerichoOS Booting...', 13, 10, 0   ; 13=CR, 10=LF, 0=NULL

;------------------------------------------------------------------------------
; Padding and Boot Signature
;------------------------------------------------------------------------------
times 510-($-$$) db 0   ; Fill remaining space with zeros up to byte 510
dw 0xAA55               ; Boot signature (must be at bytes 510-511)
